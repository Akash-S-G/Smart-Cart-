{"ast":null,"code":"import create from 'zustand';\nimport { io } from 'socket.io-client';\nimport { devtools } from 'zustand/middleware';\nconst API_URL = process.env.REACT_APP_API_URL || 'http://192.168.74.207:5000';\n\n// Custom middleware to handle WebSocket reconnection\nconst socketMiddleware = config => (set, get, api) => {\n  const initialState = config((...args) => {\n    set(...args);\n  }, get, api);\n  let reconnectTimer = null;\n  let reconnectAttempts = 0;\n  const MAX_RECONNECT_ATTEMPTS = 5;\n  const RECONNECT_INTERVAL = 5000;\n  return {\n    ...initialState,\n    initializeSocket: cartId => {\n      if (!cartId) {\n        console.warn('No cart ID provided for socket connection');\n        return;\n      }\n\n      // Clear any existing reconnect timer\n      if (reconnectTimer) {\n        clearTimeout(reconnectTimer);\n        reconnectTimer = null;\n      }\n\n      // If there's an existing connection for this cart, don't create a new one\n      const currentSocket = get().socket;\n      if (currentSocket !== null && currentSocket !== void 0 && currentSocket.connected && get().cartId === cartId) {\n        console.log('Socket already connected for cart:', cartId);\n        return;\n      }\n\n      // Cleanup existing socket if any\n      if (currentSocket) {\n        currentSocket.disconnect();\n      }\n\n      // Reset connection state\n      reconnectAttempts = 0;\n      set({\n        error: null\n      });\n\n      // Create new socket connection\n      const socket = io(API_URL, {\n        query: {\n          cart_id: cartId\n        },\n        reconnection: true,\n        reconnectionAttempts: MAX_RECONNECT_ATTEMPTS,\n        reconnectionDelay: RECONNECT_INTERVAL,\n        timeout: 10000,\n        transports: ['websocket', 'polling'],\n        // Enable both WebSocket and polling\n        upgrade: true,\n        // Allow transport upgrade\n        rememberUpgrade: true\n      });\n\n      // Socket event handlers\n      socket.on('connect', () => {\n        console.log('Socket connected for cart:', cartId);\n        reconnectAttempts = 0;\n        set({\n          isConnected: true,\n          error: null\n        });\n      });\n      socket.on('connection_confirmed', data => {\n        console.log('Connection confirmed:', data);\n      });\n      socket.on('disconnect', reason => {\n        console.log('Socket disconnected:', reason);\n        set({\n          isConnected: false\n        });\n\n        // Only attempt to reconnect if we haven't reached max attempts\n        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\n          reconnectTimer = setTimeout(() => {\n            reconnectAttempts++;\n            console.log(`Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);\n            socket.connect();\n          }, RECONNECT_INTERVAL);\n        } else {\n          set({\n            error: 'Maximum reconnection attempts reached'\n          });\n        }\n      });\n      socket.on('connect_error', error => {\n        console.error('Socket connection error:', error);\n        set({\n          error: error.message\n        });\n      });\n      socket.on('frame_update', frameData => {\n        set({\n          lastFrame: frameData\n        });\n      });\n      set({\n        socket,\n        cartId\n      });\n    },\n    disconnect: () => {\n      const {\n        socket\n      } = get();\n      if (socket) {\n        if (reconnectTimer) {\n          clearTimeout(reconnectTimer);\n          reconnectTimer = null;\n        }\n        socket.disconnect();\n        set({\n          socket: null,\n          isConnected: false,\n          cartId: null,\n          lastFrame: null\n        });\n      }\n    },\n    cleanup: () => {\n      const {\n        disconnect\n      } = get();\n      disconnect();\n    }\n  };\n};\nconst useWebSocketStore = create(devtools(socketMiddleware((set, get) => ({\n  socket: null,\n  isConnected: false,\n  cartId: null,\n  error: null,\n  lastFrame: null\n}))));\nexport default useWebSocketStore;","map":{"version":3,"names":["create","io","devtools","API_URL","process","env","REACT_APP_API_URL","socketMiddleware","config","set","get","api","initialState","args","reconnectTimer","reconnectAttempts","MAX_RECONNECT_ATTEMPTS","RECONNECT_INTERVAL","initializeSocket","cartId","console","warn","clearTimeout","currentSocket","socket","connected","log","disconnect","error","query","cart_id","reconnection","reconnectionAttempts","reconnectionDelay","timeout","transports","upgrade","rememberUpgrade","on","isConnected","data","reason","setTimeout","connect","message","frameData","lastFrame","cleanup","useWebSocketStore"],"sources":["C:/Users/akash/Desktop/MODEL/SmartCart/frontend/src/stores/websocketStore.js"],"sourcesContent":["import create from 'zustand';\nimport { io } from 'socket.io-client';\nimport { devtools } from 'zustand/middleware';\n\nconst API_URL = process.env.REACT_APP_API_URL || 'http://192.168.74.207:5000';\n\n// Custom middleware to handle WebSocket reconnection\nconst socketMiddleware = (config) => (set, get, api) => {\n  const initialState = config(\n    (...args) => {\n      set(...args);\n    },\n    get,\n    api\n  );\n\n  let reconnectTimer = null;\n  let reconnectAttempts = 0;\n  const MAX_RECONNECT_ATTEMPTS = 5;\n  const RECONNECT_INTERVAL = 5000;\n\n  return {\n    ...initialState,\n    initializeSocket: (cartId) => {\n      if (!cartId) {\n        console.warn('No cart ID provided for socket connection');\n        return;\n      }\n\n      // Clear any existing reconnect timer\n      if (reconnectTimer) {\n        clearTimeout(reconnectTimer);\n        reconnectTimer = null;\n      }\n\n      // If there's an existing connection for this cart, don't create a new one\n      const currentSocket = get().socket;\n      if (currentSocket?.connected && get().cartId === cartId) {\n        console.log('Socket already connected for cart:', cartId);\n        return;\n      }\n\n      // Cleanup existing socket if any\n      if (currentSocket) {\n        currentSocket.disconnect();\n      }\n\n      // Reset connection state\n      reconnectAttempts = 0;\n      set({ error: null });\n\n      // Create new socket connection\n      const socket = io(API_URL, {\n        query: { cart_id: cartId },\n        reconnection: true,\n        reconnectionAttempts: MAX_RECONNECT_ATTEMPTS,\n        reconnectionDelay: RECONNECT_INTERVAL,\n        timeout: 10000,\n        transports: ['websocket', 'polling'], // Enable both WebSocket and polling\n        upgrade: true, // Allow transport upgrade\n        rememberUpgrade: true,\n      });\n\n      // Socket event handlers\n      socket.on('connect', () => {\n        console.log('Socket connected for cart:', cartId);\n        reconnectAttempts = 0;\n        set({ isConnected: true, error: null });\n      });\n\n      socket.on('connection_confirmed', (data) => {\n        console.log('Connection confirmed:', data);\n      });\n\n      socket.on('disconnect', (reason) => {\n        console.log('Socket disconnected:', reason);\n        set({ isConnected: false });\n\n        // Only attempt to reconnect if we haven't reached max attempts\n        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\n          reconnectTimer = setTimeout(() => {\n            reconnectAttempts++;\n            console.log(`Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);\n            socket.connect();\n          }, RECONNECT_INTERVAL);\n        } else {\n          set({ error: 'Maximum reconnection attempts reached' });\n        }\n      });\n\n      socket.on('connect_error', (error) => {\n        console.error('Socket connection error:', error);\n        set({ error: error.message });\n      });\n\n      socket.on('frame_update', (frameData) => {\n        set({ lastFrame: frameData });\n      });\n\n      set({ socket, cartId });\n    },\n\n    disconnect: () => {\n      const { socket } = get();\n      if (socket) {\n        if (reconnectTimer) {\n          clearTimeout(reconnectTimer);\n          reconnectTimer = null;\n        }\n        socket.disconnect();\n        set({ socket: null, isConnected: false, cartId: null, lastFrame: null });\n      }\n    },\n\n    cleanup: () => {\n      const { disconnect } = get();\n      disconnect();\n    }\n  };\n};\n\nconst useWebSocketStore = create(\n  devtools(\n    socketMiddleware((set, get) => ({\n      socket: null,\n      isConnected: false,\n      cartId: null,\n      error: null,\n      lastFrame: null,\n    }))\n  )\n);\n\nexport default useWebSocketStore;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}