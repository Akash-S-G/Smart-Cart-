{"ast":null,"code":"import create from 'zustand';\nimport { io } from 'socket.io-client';\nimport { devtools } from 'zustand/middleware';\nconst API_URL = process.env.REACT_APP_API_URL || 'http://192.168.175.155:5000';\nconst socketMiddleware = config => (set, get, api) => {\n  const initialState = config((...args) => {\n    set(...args);\n  }, get, api);\n  let socket = null;\n  let reconnectTimer = null;\n  let isUnmounting = false;\n  const MAX_RECONNECT_ATTEMPTS = 5;\n  const BASE_RECONNECT_DELAY = 1000;\n  const clearReconnectTimer = () => {\n    if (reconnectTimer) {\n      clearTimeout(reconnectTimer);\n      reconnectTimer = null;\n    }\n  };\n  const createSocketConnection = cartId => {\n    try {\n      // Create new socket connection\n      socket = io(API_URL, {\n        query: {\n          cart_id: cartId\n        },\n        transports: ['websocket'],\n        upgrade: false,\n        reconnection: true,\n        reconnectionAttempts: MAX_RECONNECT_ATTEMPTS,\n        reconnectionDelay: BASE_RECONNECT_DELAY,\n        reconnectionDelayMax: 5000,\n        timeout: 10000\n      });\n\n      // Socket event handlers\n      socket.on('connect', () => {\n        console.log('Socket connected for cart:', cartId);\n        if (!isUnmounting) {\n          set({\n            isConnected: true,\n            error: null,\n            reconnectAttempts: 0,\n            socket,\n            // Store socket instance in state\n            cartId\n          });\n        }\n      });\n      socket.on('connection_confirmed', data => {\n        console.log('Connection confirmed:', data);\n        if (!isUnmounting) {\n          set({\n            maxConnections: data.max_connections,\n            reconnectCooldown: data.cooldown * 1000\n          });\n        }\n      });\n      socket.on('disconnect', reason => {\n        console.log('Socket disconnected:', reason);\n        if (!isUnmounting) {\n          set({\n            isConnected: false\n          });\n        }\n      });\n      socket.on('connect_error', error => {\n        console.error('Socket connection error:', error);\n        if (!isUnmounting) {\n          set({\n            error: error.message\n          });\n        }\n      });\n      socket.on('frame_update', frameData => {\n        if (frameData.cart_id === cartId && !isUnmounting) {\n          set({\n            lastFrame: frameData.frame,\n            error: null\n          });\n        }\n      });\n      return socket;\n    } catch (error) {\n      console.error('Error creating socket connection:', error);\n      if (!isUnmounting) {\n        set({\n          error: error.message\n        });\n      }\n      return null;\n    }\n  };\n  return {\n    ...initialState,\n    initializeSocket: cartId => {\n      if (!cartId) {\n        console.warn('No cart ID provided for socket connection');\n        return;\n      }\n      isUnmounting = false;\n\n      // Clear any existing reconnect timer\n      clearReconnectTimer();\n\n      // Get current socket from state\n      const currentSocket = get().socket;\n\n      // If there's an existing connection for this cart, don't create a new one\n      if (currentSocket !== null && currentSocket !== void 0 && currentSocket.connected && get().cartId === cartId) {\n        console.log('Socket already connected for cart:', cartId);\n        return;\n      }\n\n      // Cleanup existing socket if any\n      if (currentSocket) {\n        currentSocket.disconnect();\n      }\n\n      // Reset connection state\n      set({\n        socket: null,\n        error: null,\n        reconnectAttempts: 0,\n        isConnected: false,\n        cartId: null,\n        lastFrame: null\n      });\n\n      // Create new connection\n      createSocketConnection(cartId);\n    },\n    disconnect: () => {\n      isUnmounting = true;\n      clearReconnectTimer();\n      const currentSocket = get().socket;\n      if (currentSocket) {\n        currentSocket.disconnect();\n        currentSocket.removeAllListeners();\n      }\n      // Only update state if not unmounting\n      if (!isUnmounting) {\n        set({\n          socket: null,\n          isConnected: false,\n          cartId: null,\n          lastFrame: null,\n          error: null,\n          reconnectAttempts: 0\n        });\n      }\n    },\n    cleanup: () => {\n      const {\n        disconnect\n      } = get();\n      disconnect();\n    }\n  };\n};\nconst useWebSocketStore = create(devtools(socketMiddleware(set => ({\n  socket: null,\n  isConnected: false,\n  cartId: null,\n  error: null,\n  lastFrame: null,\n  reconnectAttempts: 0,\n  maxConnections: 1,\n  reconnectCooldown: 1000\n}))));\nexport default useWebSocketStore;","map":{"version":3,"names":["create","io","devtools","API_URL","process","env","REACT_APP_API_URL","socketMiddleware","config","set","get","api","initialState","args","socket","reconnectTimer","isUnmounting","MAX_RECONNECT_ATTEMPTS","BASE_RECONNECT_DELAY","clearReconnectTimer","clearTimeout","createSocketConnection","cartId","query","cart_id","transports","upgrade","reconnection","reconnectionAttempts","reconnectionDelay","reconnectionDelayMax","timeout","on","console","log","isConnected","error","reconnectAttempts","data","maxConnections","max_connections","reconnectCooldown","cooldown","reason","message","frameData","lastFrame","frame","initializeSocket","warn","currentSocket","connected","disconnect","removeAllListeners","cleanup","useWebSocketStore"],"sources":["C:/Users/akash/Desktop/MODEL/SmartCart/frontend/src/stores/websocketStore.js"],"sourcesContent":["import create from 'zustand';\nimport { io } from 'socket.io-client';\nimport { devtools } from 'zustand/middleware';\n\nconst API_URL = process.env.REACT_APP_API_URL || 'http://192.168.175.155:5000';\n\nconst socketMiddleware = (config) => (set, get, api) => {\n  const initialState = config((...args) => { set(...args); }, get, api);\n\n  let socket = null;\n  let reconnectTimer = null;\n  let isUnmounting = false;\n  const MAX_RECONNECT_ATTEMPTS = 5;\n  const BASE_RECONNECT_DELAY = 1000;\n\n  const clearReconnectTimer = () => {\n    if (reconnectTimer) {\n      clearTimeout(reconnectTimer);\n      reconnectTimer = null;\n    }\n  };\n\n  const createSocketConnection = (cartId) => {\n    try {\n      // Create new socket connection\n      socket = io(API_URL, {\n        query: { cart_id: cartId },\n        transports: ['websocket'],\n        upgrade: false,\n        reconnection: true,\n        reconnectionAttempts: MAX_RECONNECT_ATTEMPTS,\n        reconnectionDelay: BASE_RECONNECT_DELAY,\n        reconnectionDelayMax: 5000,\n        timeout: 10000,\n      });\n\n      // Socket event handlers\n      socket.on('connect', () => {\n        console.log('Socket connected for cart:', cartId);\n        if (!isUnmounting) {\n          set({ \n            isConnected: true, \n            error: null,\n            reconnectAttempts: 0,\n            socket, // Store socket instance in state\n            cartId\n          });\n        }\n      });\n\n      socket.on('connection_confirmed', (data) => {\n        console.log('Connection confirmed:', data);\n        if (!isUnmounting) {\n          set({ \n            maxConnections: data.max_connections,\n            reconnectCooldown: data.cooldown * 1000\n          });\n        }\n      });\n\n      socket.on('disconnect', (reason) => {\n        console.log('Socket disconnected:', reason);\n        if (!isUnmounting) {\n          set({ isConnected: false });\n        }\n      });\n\n      socket.on('connect_error', (error) => {\n        console.error('Socket connection error:', error);\n        if (!isUnmounting) {\n          set({ error: error.message });\n        }\n      });\n\n      socket.on('frame_update', (frameData) => {\n        if (frameData.cart_id === cartId && !isUnmounting) {\n          set({ \n            lastFrame: frameData.frame,\n            error: null\n          });\n        }\n      });\n\n      return socket;\n    } catch (error) {\n      console.error('Error creating socket connection:', error);\n      if (!isUnmounting) {\n        set({ error: error.message });\n      }\n      return null;\n    }\n  };\n\n  return {\n    ...initialState,\n    initializeSocket: (cartId) => {\n      if (!cartId) {\n        console.warn('No cart ID provided for socket connection');\n        return;\n      }\n\n      isUnmounting = false;\n      \n      // Clear any existing reconnect timer\n      clearReconnectTimer();\n\n      // Get current socket from state\n      const currentSocket = get().socket;\n\n      // If there's an existing connection for this cart, don't create a new one\n      if (currentSocket?.connected && get().cartId === cartId) {\n        console.log('Socket already connected for cart:', cartId);\n        return;\n      }\n\n      // Cleanup existing socket if any\n      if (currentSocket) {\n        currentSocket.disconnect();\n      }\n\n      // Reset connection state\n      set({ \n        socket: null,\n        error: null,\n        reconnectAttempts: 0,\n        isConnected: false,\n        cartId: null,\n        lastFrame: null\n      });\n\n      // Create new connection\n      createSocketConnection(cartId);\n    },\n\n    disconnect: () => {\n      isUnmounting = true;\n      clearReconnectTimer();\n      const currentSocket = get().socket;\n      if (currentSocket) {\n        currentSocket.disconnect();\n        currentSocket.removeAllListeners();\n      }\n      // Only update state if not unmounting\n      if (!isUnmounting) {\n        set({ \n          socket: null,\n          isConnected: false,\n          cartId: null,\n          lastFrame: null,\n          error: null,\n          reconnectAttempts: 0\n        });\n      }\n    },\n\n    cleanup: () => {\n      const { disconnect } = get();\n      disconnect();\n    }\n  };\n};\n\nconst useWebSocketStore = create(\n  devtools(\n    socketMiddleware((set) => ({\n      socket: null,\n      isConnected: false,\n      cartId: null,\n      error: null,\n      lastFrame: null,\n      reconnectAttempts: 0,\n      maxConnections: 1,\n      reconnectCooldown: 1000\n    }))\n  )\n);\n\nexport default useWebSocketStore;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}